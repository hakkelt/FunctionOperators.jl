<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference Â· FunctionOperators.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FunctionOperators.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">FunctionOperators.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">FunctionOperators.jl</a></li><li><a class="tocitem" href="../Tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/hakkelt/FunctionOperators.jl/blob/master/docs/src-staging/reference.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.setPlan" href="#FunctionOperators.setPlan"><code>FunctionOperators.setPlan</code></a> â€” <span class="docstring-category">Function</span></header><section><div><p>Manually set the plan of a FunctionOperator Arguments:</p><ul><li><code>FO</code> composite FunctionOperator to be changed</li><li><code>f</code> manually defined plan (function with two arguments, first is the output buffer, second is the input array)</li><li><code>f_str</code> (Optional) string representation of the plan</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/Auxiliary.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.FunOp" href="#FunctionOperators.FunOp"><code>FunctionOperators.FunOp</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>Supertype for FunctionOperator and FunctionOperatorComposite</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/StructDefs.jl#L9-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.FunctionOperator" href="#FunctionOperators.FunctionOperator"><code>FunctionOperators.FunctionOperator</code></a> â€” <span class="docstring-category">Type</span></header><section><div><p>FunctionOperator is an operator that maps from a multidimensional space to another multidimensional space. The mapping is defined by a function (<code>forw</code>), and optionally the reverse mapping can also be defined (<code>backw</code>). The input the mapping must be subtype of AbstractArray.</p><p>The following constructors are available:</p><ul><li>Positional constructor #1: <code>FunctionOperator{eltype}(forw, inDims, outDims)</code></li><li>Positional constructor #2: <code>FunctionOperator{eltype}(forw, backw, inDims, outDims)</code></li><li>Positional constructor #3: <code>FunctionOperator{eltype}(name, forw, inDims, outDims)</code></li><li>Positional constructor #4: <code>FunctionOperator{eltype}(name, forw, backw, inDims, outDims)</code></li><li>Keyword constructor: <code>FunctionOperator{eltype}(;kwargs...)</code></li></ul><p>where <code>eltype</code> is the type enforced on elements of input array.</p><p>Arguments</p><ul><li><code>name::String</code> (Optional but strongly recommended) The operator is referenced later in error messages by this string. <strong>Warning!</strong> It is also used to check equality of (composite) FunctionOperators. Default value: <code>OpX</code> where X is a number incremented in each constructor-call.</li><li><code>forw::Function</code> Function defining the mapping. Must accept one or two arguments. In case of two arguments, the first argument is a preallocated buffer to write the result into (to speed up code by avoiding repeated allocations). In case of both one and two arguments, the return value must be the result of the mapping.</li><li><code>backw::Function</code> (Optional) Same as backw, but defines the backward mapping</li><li><code>inDims::Tuple{Vararg{Int}}</code> Size of input array</li><li><code>outDims::Tuple{Vararg{Int}}</code> Size of output array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.@recycle-Tuple{Any}" href="#FunctionOperators.@recycle-Tuple{Any}"><code>FunctionOperators.@recycle</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><p>Speed up iteratively executed code fragments with many matrix operations by transforming code in such a way that preserves arrays allocated for intermediate results, and re-use them for subsequent iterations.</p><p>First variant:</p><pre class="language-julia"><code class="language-julia">@recycle &lt;code to be optimized&gt;</code></pre><p>Second variant:</p><pre class="language-julia"><code class="language-julia">@recycle(arrays = [&lt;list of array variables&gt;], funops = [&lt;list of funop variables], numbers = [&lt;list of number variables&gt;], &lt;code to be optimized&gt;)</code></pre><p>The <strong>first variant</strong> is the more convenient one that tries to guess the type of variables (the other variant requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. As a tradeoff, this variant fails when the optimized code contains either a closure or non-const global variable.</p><p>The <strong>second variant</strong> is the more flexible (and also more verbose) one one that requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. The other variant tries to guess the type of variables, thus it is more convenient, but as a tradeoff, that variant fails when the optimized code contains either a closure or non-const global variable. On the other hand, this (more verbose) variant is free from these limitations. <em>Note: All of the &quot;keyword arguments&quot; are optional, and also their order is arbitrary.</em></p><p>An example to first variant: This function</p><pre class="language-julia"><code class="language-julia">function foo()
    A = rand(100,100)
    B = rand(100,100)
    @recycle for i = 1:5
        A += A / 2 + B
        C = A * B + 5
    end
end</code></pre><p>is turned into the following:</p><pre class="language-julia"><code class="language-julia">function foo()
    A = rand(100,100)
    B = rand(100,100)
    (C, ğŸ”ƒâ‚‚) = fill(nothing, 2)
    (is_first_runâ‚,) = fill(true, 1)
    for i = 1:5
        A .+= A ./ 2 .+ B
        if is_first_runâ‚
            is_first_runâ‚ = false
            ğŸ”ƒâ‚‚ = A * B
            C = ğŸ”ƒâ‚‚ .+ 5
        else
            mul!(ğŸ”ƒâ‚‚, A, B)
            C .= ğŸ”ƒâ‚‚ .+ 5
        end
    end
end</code></pre><p>Another example showing what second variant can do (and the first can&#39;t):</p><pre class="language-julia"><code class="language-julia">bar = @recycle(arrays=[A,B], (A, B) -&gt; begin
    A += A / 2 + B
    B = A * B .+ 5
end)
function baz()
    A = rand(100,100)
    B = rand(100,100)
    for i = 1:5
        bar(A,B)
    end
end</code></pre><p>is turned into the following:</p><pre class="language-julia"><code class="language-julia">bar = begin
    (ğŸ”ƒâ‚,) = fill(nothing, 1)
    (is_first_runâ‚,) = fill(true, 1)
    (A, B)-&gt;begin
            A .+= A ./ 2 .+ B
            begin
                if is_first_runâ‚
                    is_first_runâ‚ = false
                    ğŸ”ƒâ‚ = A * B
                else
                    mul!(ğŸ”ƒâ‚, A, B)
                end
                B .= ğŸ”ƒâ‚ .+ 5
            end
        end
end
function baz()
    A = rand(100,100)
    B = rand(100,100)
    for i = 1:5
        bar(A,B)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/recycle.jl#L445-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.@â™»-Tuple{Any}" href="#FunctionOperators.@â™»-Tuple{Any}"><code>FunctionOperators.@â™»</code></a> â€” <span class="docstring-category">Macro</span></header><section><div><p><strong>Recycling macro</strong>: Reduce the number of allocations inside a for loop by preallocation of arrays for the outputs of marked operations. Markers: <code>@â™»</code> (<code>\:recycle:</code>), <code>ğŸ”</code> (<code>\:top:</code>), <code>ğŸ”ƒ</code> (<code>\:arrows_clockwise:</code>), and <code>@ğŸ”ƒ</code></p><p>Macro @â™» should be placed right before a for loop, and then it executes the following substitutions:</p><ul><li><strong>Expressions marked by <code>ğŸ”</code>:</strong></li></ul><p>They are going to be calculated before the loop, the result is stored in a variable, and the expression will be replaced by that variable. It also can be useful when a constant expression is used in the loop, but the idea behind creating that substitution is to allow caching of composite FunctionMatrices. Eg:</p><pre class="language-julia"><code class="language-julia">@â™» for i=1:5
    result = ğŸ”((FuncOpâ‚ + 2I) * FuncOpâ‚‚) * data
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">ğŸ”_1 = (FuncOpâ‚ + 2I) * FuncOpâ‚‚
for i = 1:5
    result = ğŸ”_1 * data
end</code></pre><p>so that way plan is calculated only once, and also buffers for intermediate results of the composite operator are allocated once.</p><ul><li><strong>Expressions marked by <code>ğŸ”ƒ</code>:</strong></li></ul><p>They are going to be calculated before the loop (to allocate an array to store the result), but the expression is also evaluated in each loop iteration. The difference after the substitution is that the result of the expression is always saved to the preallocated array. Eg:</p><pre class="language-julia"><code class="language-julia">@â™» for i=1:5
    result = FuncOpâ‚ * ğŸ”ƒ(A + B)
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">ğŸ”ƒ_1 = A + B
for i = 1:5
    result = FuncOpâ‚ * @.(ğŸ”ƒ_1 = A + B)
end</code></pre><p>This transformation first allocates an array named <code>ğŸ”ƒ_1</code>, and then in every iteration it is recalculated, saved to <code>ğŸ”ƒ_1</code>, and the this value is used for the rest of the operation (i.e.: <code>FuncOpâ‚ * ğŸ”ƒ_1</code>. Note that <code>@.</code> macro is inserted before the inline assignment. This is needed otherwise <code>A + B</code> would allocate a new array before it is stored in <code>ğŸ”ƒ_1</code>. <strong>Warning!</strong> It can break your code, e.g. <code>@.(ğŸ”ƒ_1 = A * B) â‰  (ğŸ”ƒ_1 = A .* B)</code> {matrix multiplication vs. elementwise multiplication}! On the other hand, when the marked expression consists only a multiplication, then it is transformed into a call of <code>mul!</code>. Eg:</p><pre class="language-julia"><code class="language-julia">@â™» for i=1:5
    result = FuncOpâ‚ * ğŸ”ƒ(A * B)
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">ğŸ”ƒ_1 = A * B
for i = 1:5
    result = FuncOpâ‚ * mul!(ğŸ”ƒ_1, A, B)
end</code></pre><ul><li><strong>Lastly, assignments marked by <code>@ğŸ”ƒ</code>:</strong></li></ul><p>They will be transformed into a call of <code>mul!</code>. Of course, it works only if <code>@ğŸ”ƒ</code> is directly followed by an assignment that has a single multiplication on the right side. Eg:</p><pre class="language-julia"><code class="language-julia">@â™» for i=1:5
    @ğŸ”ƒ result = FuncOpâ‚ * A
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">result = FuncOpâ‚ * A
for i = 1:5
    mul!(result, FuncOpâ‚, A)
end</code></pre><p>Final note: <code>ğŸ”</code> can be arbitrarily nested, and it can be embedded in expressions marked by <code>ğŸ”ƒ</code>. <code>ğŸ”ƒ</code> can also be nested, and it can be used in assigments marked by <code>@ğŸ”ƒ</code> (along with <code>ğŸ”</code>, of course).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/Auxiliary.jl#L108-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunctionOperators.FunctionOperators_global_settings" href="#FunctionOperators.FunctionOperators_global_settings"><code>FunctionOperators.FunctionOperators_global_settings</code></a> â€” <span class="docstring-category">Constant</span></header><section><div><p>Object that holds global settings for <code>FunctionOperators</code> library</p><p>Fields:</p><ul><li><code>verbose::Bool</code> If set to true, then allocation information and calculated plan function will be displayed upon creation (i.e., when a composite operator is first used). Default: <code>false</code></li><li><code>macro_verbose::Bool</code> If set to true, then recycling macros (@â™» and @recycle) will print the transformed code. Default: <code>false</code></li><li><code>auto_reshape::Bool</code> If set to true, then input and output is reshaped according to the inDims and outDims values of the FunctionOperator before and after any multiplication. Default: <code>false</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/FunctionOperators.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{FunctionOperators.FunctionOperatorComposite,FunctionOperators.FunctionOperatorComposite}" href="#Base.:==-Tuple{FunctionOperators.FunctionOperatorComposite,FunctionOperators.FunctionOperatorComposite}"><code>Base.:==</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Equality check based on name</p><p><strong>HEADS UP!</strong> This works only when operators with the same name has also the same functionality!</p><p>It performs basic arithmetic transformations on the expressions, so it recognizes even some less obvious equalities. The rules it uses:</p><ul><li>Associativity: <span>$op1 * op2 * op3 = (op1 * op2) * op3 = op1 * (op2 * op3)$</span>, <span>$op1 + op2 + op3 = (op1 + op2) + op3 = op1 + (op2 + op3)$</span>, <span>$op1 + (op2 - op3) == (op1 + op2) - op3$</span>, <span>$op1 - (op2 + op3) == (op1 - op2) - op3$</span></li><li>Commutativity: <span>$op1 - op2 - op3 = op1 - op3 - op2$</span>, <span>$op1 + op2 = op2 + op1$</span></li><li>Distributivity: <span>$(op1 + op2) * op3 = op1 * op3 + op2 * op3$</span> (Note that <span>$op1 * (op2 + op3) â‰  op1 * op2 + op1 * op3$</span>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/Auxiliary.jl#L92-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{Type{FunctionOperator{T}}}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{Type{FunctionOperator{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a> â€” <span class="docstring-category">Method</span></header><section><div><p>Determine type of elements of array accepted by this operator</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/ba0818e7e006bf433ad6d6f5d3523abb56fb2a8e/src/Helpers.jl#L10">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Tutorial/">Â« Tutorial</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 8 December 2019 14:37">Sunday 8 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
