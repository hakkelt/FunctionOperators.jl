<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · FunctionOperators.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.svg" alt="FunctionOperators.jl logo"/></a><h1>FunctionOperators.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">FunctionOperators.jl</a></li><li><a class="toctext" href="../Tutorial/">Tutorial</a></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Reference-1" href="#Reference-1">Reference</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionOperators.setPlan" href="#FunctionOperators.setPlan"><code>FunctionOperators.setPlan</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Manually set the plan of a FunctionOperator Arguments:</p><ul><li><code>FO</code> composite FunctionOperator to be changed</li><li><code>f</code> manually defined plan (function with two arguments, first is the output buffer, second is the input array)</li><li><code>f_str</code> (Optional) string representation of the plan</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/Auxiliary.jl#L5-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionOperators.FunOp" href="#FunctionOperators.FunOp"><code>FunctionOperators.FunOp</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Supertype for FunctionOperator and FunctionOperatorComposite</p></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/StructDefs.jl#L9-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionOperators.FunctionOperator" href="#FunctionOperators.FunctionOperator"><code>FunctionOperators.FunctionOperator</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>FunctionOperator is an operator that maps from a multidimensional space to another multidimensional space. The mapping is defined by a function (<code>forw</code>), and optionally the reverse mapping can also be defined (<code>backw</code>). The input the mapping must be subtype of AbstractArray.</p><p>The following constructors are available:</p><ul><li>Positional constructor #1: <code>FunctionOperator{eltype}(forw, inDims, outDims)</code></li><li>Positional constructor #2: <code>FunctionOperator{eltype}(forw, backw, inDims, outDims)</code></li><li>Positional constructor #3: <code>FunctionOperator{eltype}(name, forw, inDims, outDims)</code></li><li>Positional constructor #4: <code>FunctionOperator{eltype}(name, forw, backw, inDims, outDims)</code></li><li>Keyword constructor: <code>FunctionOperator{eltype}(;kwargs...)</code></li></ul><p>where <code>eltype</code> is the type enforced on elements of input array.</p><p>Arguments</p><ul><li><code>name::String</code> (Optional but strongly recommended) The operator is referenced later in error messages by this string. <strong>Warning!</strong> It is also used to check equality of (composite) FunctionOperators. Default value: <code>OpX</code> where X is a number incremented in each constructor-call.</li><li><code>forw::Function</code> Function defining the mapping. Must accept one or two arguments. In case of two arguments, the first argument is a preallocated buffer to write the result into (to speed up code by avoiding repeated allocations). In case of both one and two arguments, the return value must be the result of the mapping.</li><li><code>backw::Function</code> (Optional) Same as backw, but defines the backward mapping</li><li><code>inDims::Tuple{Vararg{Int}}</code> Size of input array</li><li><code>outDims::Tuple{Vararg{Int}}</code> Size of output array</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/55e36cc308b66d3472990a06b2797f9f9154ea0a/base/#L0-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionOperators.@♻-Tuple{Any}" href="#FunctionOperators.@♻-Tuple{Any}"><code>FunctionOperators.@♻</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p><strong>Recycling macro</strong>: Reduce the number of allocations inside a for loop by preallocation of arrays for the outputs of marked operations. Markers: <code>@♻</code> (<code>\:recycle:</code>), <code>🔝</code> (<code>\:top:</code>), <code>🔃</code> (<code>\:arrows_clockwise:</code>), and <code>@🔃</code></p><p>Macro @♻ should be placed right before a for loop, and then it executes the following substitutions:</p><ul><li><strong>Expressions marked by <code>🔝</code>:</strong></li></ul><p>They are going to be calculated before the loop, the result is stored in a variable, and the expression will be replaced by that variable. It also can be useful when a constant expression is used in the loop, but the idea behind creating that substitution is to allow caching of composite FunctionMatrices. Eg:</p><pre class="language-julia"><code class="language-julia">@♻ for i=1:5
    result = 🔝((FuncOp₁ + 2I) * FuncOp₂) * data
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">🔝_1 = (FuncOp₁ + 2I) * FuncOp₂
for i = 1:5
    result = 🔝_1 * data
end</code></pre><p>so that way plan is calculated only once, and also buffers for intermediate results of the composite operator are allocated once.</p><ul><li><strong>Expressions marked by <code>🔃</code>:</strong></li></ul><p>They are going to be calculated before the loop (to allocate an array to store the result), but the expression is also evaluated in each loop iteration. The difference after the substitution is that the result of the expression is always saved to the preallocated array. Eg:</p><pre class="language-julia"><code class="language-julia">@♻ for i=1:5
    result = FuncOp₁ * 🔃(A + B)
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">🔃_1 = A + B
for i = 1:5
    result = FuncOp₁ * @.(🔃_1 = A + B)
end</code></pre><p>This transformation first allocates an array named <code>🔃_1</code>, and then in every iteration it is recalculated, saved to <code>🔃_1</code>, and the this value is used for the rest of the operation (i.e.: <code>FuncOp₁ * 🔃_1</code>. Note that <code>@.</code> macro is inserted before the inline assignment. This is needed otherwise <code>A + B</code> would allocate a new array before it is stored in <code>🔃_1</code>. <strong>Warning!</strong> It can break your code, e.g. <code>@.(🔃_1 = A * B) ≠ (🔃_1 = A .* B)</code> {matrix multiplication vs. elementwise multiplication}! On the other hand, when the marked expression consists only a multiplication, then it is transformed into a call of <code>mul!</code>. Eg:</p><pre class="language-julia"><code class="language-julia">@♻ for i=1:5
    result = FuncOp₁ * 🔃(A * B)
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">🔃_1 = A * B
for i = 1:5
    result = FuncOp₁ * mul!(🔃_1, A, B)
end</code></pre><ul><li><strong>Lastly, assignments marked by <code>@🔃</code>:</strong></li></ul><p>They will be transformed into a call of <code>mul!</code>. Of course, it works only if <code>@🔃</code> is directly followed by an assignment that has a single multiplication on the right side. Eg:</p><pre class="language-julia"><code class="language-julia">@♻ for i=1:5
    @🔃 result = FuncOp₁ * A
end</code></pre><p>will be transformed to </p><pre class="language-julia"><code class="language-julia">result = FuncOp₁ * A
for i = 1:5
    mul!(result, FuncOp₁, A)
end</code></pre><p>Final note: <code>🔝</code> can be arbitrarily nested, and it can be embedded in expressions marked by <code>🔃</code>. <code>🔃</code> can also be nested, and it can be used in assigments marked by <code>@🔃</code> (along with <code>🔝</code>, of course).</p></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/Auxiliary.jl#L135-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FunctionOperators.FO_settings" href="#FunctionOperators.FO_settings"><code>FunctionOperators.FO_settings</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><p>Object that holds global settings for <code>FunctionOperators</code> library</p><p>Fields:</p><ul><li><code>verbose::Bool</code> If set to true, then allocation information and calculated plan function will be displayed upon creation (i.e., when a composite operator is first used). Default: <code>false</code></li><li><code>macro_verbose::Bool</code> If set to true, then recycling macro (@♻) will print the transformed loop. Default: <code>false</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/FunctionOperators.jl#L12-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==-Tuple{FunctionOperators.FunctionOperatorComposite,FunctionOperators.FunctionOperatorComposite}" href="#Base.:==-Tuple{FunctionOperators.FunctionOperatorComposite,FunctionOperators.FunctionOperatorComposite}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Equality check based on name</p><p><strong>HEADS UP!</strong> This works only when operators with the same name has also the same functionality!</p><p>It performs basic arithmetic transformations on the expressions, so it recognizes even some less obvious equalities. The rules it uses:</p><ul><li>Associativity: <span>$op1 * op2 * op3 = (op1 * op2) * op3 = op1 * (op2 * op3)$</span>, <span>$op1 + op2 + op3 = (op1 + op2) + op3 = op1 + (op2 + op3)$</span>, <span>$op1 + (op2 - op3) == (op1 + op2) - op3$</span>, <span>$op1 - (op2 + op3) == (op1 - op2) - op3$</span></li><li>Commutativity: <span>$op1 - op2 - op3 = op1 - op3 - op2$</span>, <span>$op1 + op2 = op2 + op1$</span></li><li>Distributivity: <span>$(op1 + op2) * op3 = op1 * op3 + op2 * op3$</span> (Note that <span>$op1 * (op2 + op3) ≠ op1 * op2 + op1 * op3$</span>)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/Auxiliary.jl#L119-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.eltype-Union{Tuple{Type{FunctionOperator{T}}}, Tuple{T}} where T" href="#Base.eltype-Union{Tuple{Type{FunctionOperator{T}}}, Tuple{T}} where T"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Determine type of elements of array accepted by this operator</p></div></div><a class="source-link" target="_blank" href="https://github.com/hakkelt/FunctionOperators.jl/blob/32291b5c137b6b613e370564df5888d1cf4cfbbd/src/Helpers.jl#L10">source</a></section><footer><hr/><a class="previous" href="../Tutorial/"><span class="direction">Previous</span><span class="title">Tutorial</span></a></footer></article></body></html>
