var documenterSearchIndex = {"docs":
[{"location":"Tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"<center style=\"margin-left: -50px;\"><a href=\"https://mybinder.org/v2/gh/hakkelt/FunctionOperators.jl/master?filepath=examples%2FTutorial.ipynb\" target=\"blank\"><img src=\"https://mybinder.org/badgelogo.svg\" title=\"Binder\" alt=\"binderlink\" style=\"display:inline\"></a> or view on <a href=\"https://github.com/hakkelt/FunctionOperators.jl/blob/master/examples/Tutorial.ipynb\" target=\"blank\">GitHub</a></center>","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"using FunctionOperators\nusing BenchmarkTools","category":"page"},{"location":"Tutorial/#Generate-some-3D-data-1","page":"Tutorial","title":"Generate some 3D data","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"data = [sin(i+j+k)^2 for i=1:300, j=1:300, k=1:50]\nsize(data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(300, 300, 50)","category":"page"},{"location":"Tutorial/#Define-some-operators-1","page":"Tutorial","title":"Define some operators","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"The following constructors are available:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Positional constructor #1: FunctionOperator{eltype}(forw, inDims, outDims)\nPositional constructor #2: FunctionOperator{eltype}(forw, backw, inDims, outDims)\nPositional constructor #3: FunctionOperator{eltype}(name, forw, inDims, outDims)\nPositional constructor #4: FunctionOperator{eltype}(name, forw, backw, inDims, outDims)\nKeyword constructor: FunctionOperator{eltype}(;kwargs...)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"where eltype is the type enforced on elements of input array.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Arguments","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"name::String (Optional but strongly recommended) The operator is referenced later in error messages by this string. Warning! It is also used to check equality of (composite) FunctionOperators. Default value: OpX where X is a number incremented in each constructor-call.\nforw::Function Function defining the mapping. Must accept one or two arguments. In case of two arguments, the first argument is a preallocated buffer to write the result into (to speed up code by avoiding repeated allocations). In case of both one and two arguments, the return value must be the result of the mapping.\nbackw::Function (Optional) Same as backw, but defines the backward mapping\ninDims::Tuple{Vararg{Int}} Size of input array\noutDims::Tuple{Vararg{Int}} Size of output array","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Squaring operator and square root as its adjoint operation ⟶ Dimension preserving","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Using the keyword constructor:\nOp₁ = FunctionOperator{Float64}(name = \"Op₁\",\n    forw = x -> x.^2, backw = x -> sqrt.(x),\n    inDims = (300, 300, 50), outDims = (300, 300, 50))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperator with eltype Float64\n    Name: Op₁\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"A weighting operator that collapses the new dimension on adjoint operation ⟶ Changes size","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"weights = [sin((i-j)*l) + 1 for i=1:300, j=1:300, k=1:50, l=1:10]\n# Using the positional constructor:\nOp₂ = FunctionOperator{Float64}(\"Op₂\",\n    x -> reshape(x, 300, 300, 50, 1) .* weights, # broadcasting: 3D to 4D\n    x -> reshape(sum(x ./ weights, dims=4), 300, 300, 50),\n    (300, 300, 50), (300, 300, 50, 10))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperator with eltype Float64\n    Name: Op₂\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50, 10)","category":"page"},{"location":"Tutorial/#Apply-these-operators-to-the-data-1","page":"Tutorial","title":"Apply these operators to the data","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Apply the first operator: Left multiplication by the operator is equal to calling the forw function","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₁ * data == Op₁.forw(data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Result of application of the second operator: size increased","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"size(data), size(Op₂ * data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"((300, 300, 50), (300, 300, 50, 10))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Combine the two operators:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₂ * Op₁ * data == Op₂.forw(Op₁.forw(data))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Adjoint of operator == calling the backw function","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₁' * Op₁ * data == Op₁.backw(Op₁.forw(data))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Combine operators with addition and substraction","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₂ * (Op₁ + Op₂'*Op₂) * Op₁ * data ==\n    Op₂.forw(Op₁.forw(Op₁.forw(data)) + Op₂.backw(Op₂.forw(Op₁.forw(data))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"I is also possible to combine with UniformScaling from LinearAlgebra library","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"using LinearAlgebra\nOp₁ * I * data == Op₁.forw(data),\nOp₁ * 3I * data == Op₁.forw(3 * data),\nOp₂*(Op₁ - 2.5*I)*Op₁'*data == Op₂.forw(Op₁.forw(Op₁.backw(data))-2.5*Op₁.backw(data))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(true, true, true)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Adjoint of nested operators also work:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Op₂ * Op₁)' * (Op₂ * Op₁) * data == (Op₂ * Op₁)' * Op₂ * Op₁ * data ==\n    Op₁.backw(Op₂.backw(Op₂.forw(Op₁.forw(data))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"...but not with addition or substraction:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(Op₁ + 3I)' * data","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Sorry, I don't know how to calculate the adjoint of ((Op₁ + (3*I)))'\n\n\n\nStacktrace:\n\n [1] error(::String) at ./error.jl:33\n\n [2] getPlanAddSub(::FunctionOperators.FunctionOperatorComposite{Float64}, ::FunctionOperators.Buffer, ::Bool, ::String, ::Symbol, ::Array{FunctionOperators.Buffer,1}) at /home/hakkelt/csmri/FunctionOperators/src/getPlan.jl:105\n\n [3] getPlan at /home/hakkelt/csmri/FunctionOperators/src/getPlan.jl:133 [inlined]\n\n [4] *(::FunctionOperators.FunctionOperatorComposite{Float64}, ::Array{Float64,3}) at /home/hakkelt/csmri/FunctionOperators/src/mul.jl:46\n\n [5] top-level scope at In[12]:1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can store a combination of some operators, and apply it later to data:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"comb_OP = 5I * Op₁\ncomb_OP' * comb_OP * data == (5I * Op₁)' * (5I * Op₁) * data ==\n    Op₁.backw(conj(5)*(5*Op₁.forw(data)))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note that adjoint operation of scaling by a constant (in this case: 5) is the scaling by the conjugate of the constant (which is equal to the original constant in case of real numbers).","category":"page"},{"location":"Tutorial/#Performance-1","page":"Tutorial","title":"Performance","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Unfortunately, our naive approach above allocates a lot of memory and is quite slow (at least compared to speed we can possibly achieve)...","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark Op₂*(Op₁ - 2.5*I)*Op₁'*data","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  823.99 MiB\n  allocs estimate:  320\n  --------------\n  minimum time:     221.485 ms (1.00% GC)\n  median time:      223.937 ms (1.73% GC)\n  mean time:        233.019 ms (5.57% GC)\n  maximum time:     325.965 ms (32.51% GC)\n  --------------\n  samples:          22\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"A possible reason is that Op₂ accesses a global variable, and it is considered to be a bad practice. (See: Performance Tips)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can avoid that by wrapping the definition of Op₂ with a function:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function getOp₂()\n    weights = [sin((i-j)*l) + 1 for i=1:300, j=1:300, k=1:50, l=1:10]\n    Op₂ = FunctionOperator{Float64}(name=\"Op₂\",\n        forw = x -> reshape(x, 300, 300, 50, 1) .* weights, # broadcasting: 3D to 4D\n        backw = x -> reshape(sum(x ./ weights, dims=4), 300, 300, 50),\n        inDims=(300, 300, 50), outDims=(300, 300, 50, 10))\nend\nOp₂ = getOp₂()","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperator with eltype Float64\n    Name: Op₂\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50, 10)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark Op₂*(Op₁ - 2.5*I)*Op₁'*data","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  823.99 MiB\n  allocs estimate:  318\n  --------------\n  minimum time:     222.509 ms (0.89% GC)\n  median time:      234.822 ms (1.73% GC)\n  mean time:        244.348 ms (5.53% GC)\n  maximum time:     340.294 ms (31.26% GC)\n  --------------\n  samples:          21\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Well, it didn't solved our problem... In fact, the main reason of slowness is the excessive memory allocations; namely, all the intermediate results allocates a new array.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can avoid that by defining the forw and backw function a bit differently: They can also accept two arguments, where the first is a preallocated buffer (with appropriate size) that is supposed to hold the output of the operation:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function getBufferedOps()\n    Op₁ = FunctionOperator{Float64}(name=\"Op₁\",\n        forw = (buffer, x) -> buffer .= x.^2,\n        backw = (buffer, x) -> broadcast!(sqrt, buffer, x),\n        inDims = (300, 300, 50), outDims = (300, 300, 50))\n    weights = [sin((i-j)*l) + 1 for i=1:300, j=1:300, k=1:50, l=1:10]\n    Op₂ = FunctionOperator{Float64}(name=\"Op₂\",\n        forw = (buffer,x) -> buffer .= reshape(x, 300, 300, 50, 1) .* weights,\n        backw = (buffer,x) -> dropdims(sum!(reshape(buffer, 300, 300, 50, 1), x ./ weights), dims=4),\n        inDims=(300, 300, 50), outDims=(300, 300, 50, 10))\n    Op₁, Op₂\nend\nbOp₁, bOp₂ = getBufferedOps()","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(FunctionOperator{Float64}(Op₁, (300, 300, 50), (300, 300, 50)), FunctionOperator{Float64}(Op₂, (300, 300, 50), (300, 300, 50, 10)))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark bOp₂*(bOp₁ - 2.5*I)*bOp₁'*data","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  412.00 MiB\n  allocs estimate:  312\n  --------------\n  minimum time:     203.125 ms (0.00% GC)\n  median time:      220.364 ms (0.00% GC)\n  mean time:        215.907 ms (1.00% GC)\n  maximum time:     221.152 ms (0.00% GC)\n  --------------\n  samples:          24\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Better, but it still should be much faster...","category":"page"},{"location":"Tutorial/#Let's-have-a-look-at-what-is-under-the-hood!-1","page":"Tutorial","title":"Let's have a look at what is under the hood!","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"When we combine operators, nothing special happens, just a wrapper object is created that defines the connections between the operators:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₂*(Op₁ - 2.5*I)*Op₁'","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperatorComposite with eltype Float64\n    Name: Op₂ * (Op₁ - (2.5*I)) * Op₁'\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50, 10)\n    Plan: no plan","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Note the last last line: \"Plan: no plan\" ⟶ it is going to have a significance later...","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"The real magic happens when we apply this composite operator to data. To see what is going on behind the scenes, let's enable verbosity.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperators_global_settings.verbose = true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now, we can see, how this composite operators work: When we apply it to data, it creates a function that aggregates the functionality of all combined operators, and preallocates buffers for the intermediate results.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Op₂*(Op₁ - 2.5*I)*Op₁' * data;","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50, 10)\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw((buffer2 .= Op₁.backw(x); broadcast!(-, buffer3, Op₁.forw(buffer2), broadcast!(*, buffer3, 2.5, buffer2))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"On the other hand, bOp₁ and bOp₂ has a bit different aggregated function:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"bOp₂*(bOp₁ - 2.5*I) * bOp₁' * data;","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50, 10)\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"The good thing is that the plan (along with the preallocated buffers) is cached, so if we save the combined operator to a variable, then the plan is created only once. See the difference:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"bOp₂*(bOp₁ - 2.5*I) * bOp₁' * data\nbOp₂*(bOp₁ - 2.5*I) * bOp₁' * data;","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50, 10)\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))\nAllocation of buffer1, size: (300, 300, 50, 10)\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"combined = bOp₂*(bOp₁ - 2.5*I) * bOp₁'\ncombined * data\ncombined * data;","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50, 10)\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))\nAllocation of buffer1, size: (300, 300, 50, 10)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Now we can see that the combined object carries the plan already created:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"combined","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperatorComposite with eltype Float64\n    Name: Op₂ * (Op₁ - (2.5*I)) * Op₁'\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50, 10)\n    Plan: Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"And a side-note here: We can also set this plan manually, if the computed one is wrong, or FunctionOperators was not possible to compute. For example, adjoint of addition:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"tricky = (bOp₁ + 2.5I)'","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperatorComposite with eltype Float64\n    Name: ((Op₁ + (2.5*I)))'\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50)\n    Plan: no plan","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"tricky * data","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Sorry, I don't know how to calculate the adjoint of ((Op₁ + (2.5*I)))'\n\n\n\nStacktrace:\n\n [1] error(::String) at ./error.jl:33\n\n [2] getPlanAddSub(::FunctionOperators.FunctionOperatorComposite{Float64}, ::FunctionOperators.Buffer, ::Bool, ::String, ::Symbol, ::Array{FunctionOperators.Buffer,1}) at /home/hakkelt/csmri/FunctionOperators/src/getPlan.jl:105\n\n [3] getPlan at /home/hakkelt/csmri/FunctionOperators/src/getPlan.jl:133 [inlined]\n\n [4] *(::FunctionOperators.FunctionOperatorComposite{Float64}, ::Array{Float64,3}) at /home/hakkelt/csmri/FunctionOperators/src/mul.jl:46\n\n [5] top-level scope at In[27]:1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"setPlan(tricky, (buffer, x) -> @.(√(2 - x) / √(2x)), \"√(2 - x) / √(2x)\")\ntricky","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperatorComposite with eltype Float64\n    Name: ((Op₁ + (2.5*I)))'\n    Input dimensions: (300, 300, 50)\n    Output dimensions: (300, 300, 50)\n    Plan: √(2 - x) / √(2x)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"tricky * data == @. √(2 - data) / √(2data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Allocation of buffer1, size: (300, 300, 50)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"But back to the question of performance: If we preallocate an array for the output manually, and use mul!, then we can save also the reallocation of buffer1:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"combined = bOp₂ * (bOp₁ - 2.5*I) * bOp₁'\noutput = Array{Float64}(undef, 300, 300, 50, 10)\nmul!(output, combined, data)\nmul!(output, combined, data);","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"buffer1 = <previously allocated>\nAllocation of buffer2, size: (300, 300, 50)\nAllocation of buffer3, size: (300, 300, 50)\nPlan calculated: buffer1 .= Op₂.forw(buffer1, (buffer2 .= Op₁.backw(buffer2, x); broadcast!(-, buffer3, Op₁.forw(buffer3, buffer2), broadcast!(*, buffer2, 2.5, buffer2))))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"If we apply the combined operator multiple times, we can save a lot on computation time:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperators_global_settings.verbose = false\n@benchmark mul!(output, combined, data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  256 bytes\n  allocs estimate:  7\n  --------------\n  minimum time:     137.604 ms (0.00% GC)\n  median time:      137.707 ms (0.00% GC)\n  mean time:        137.705 ms (0.00% GC)\n  maximum time:     137.920 ms (0.00% GC)\n  --------------\n  samples:          37\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's compare it to a manually function with identical function and optimizations","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function getAggregatedFunction()\n    weights = [sin((i-j)*l) + 1 for i=1:300, j=1:300, k=1:50, l=1:10]\n    buffer2 = Array{Float64}(undef, 300, 300, 50)\n    buffer3 = Array{Float64}(undef, 300, 300, 50)\n    buffer4 = Array{Float64}(undef, 300, 300, 50)\n    (buffer, x) -> begin\n        broadcast!(sqrt, buffer2, x)  # Of course, this two lines can be optimized to\n        buffer3 .= buffer2 .^ 2       # (√x)^2 = |x|, but let's now avoid this fact\n        broadcast!(-, buffer3, buffer3, broadcast!(*, buffer4, 2.5, buffer2))\n        buffer .= reshape(buffer3, 300, 300, 50, 1) .* weights\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"getAggregatedFunction (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"aggrFun = getAggregatedFunction()\n@benchmark aggrFun(output, data)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  128 bytes\n  allocs estimate:  2\n  --------------\n  minimum time:     146.955 ms (0.00% GC)\n  median time:      147.060 ms (0.00% GC)\n  mean time:        147.075 ms (0.00% GC)\n  maximum time:     147.415 ms (0.00% GC)\n  --------------\n  samples:          34\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Basically, there is no overhead of using FunctionOperators!","category":"page"},{"location":"Tutorial/#Syntactic-sugar-1","page":"Tutorial","title":"Syntactic sugar","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Let's consider the following function:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function foo1(A, bOp₁, bOp₂)\n    for i in 1:10\n        C = (bOp₁ - 2.5*I) * bOp₁ * A\n        B = bOp₁ * (C - 3A)\n        A .= bOp₁ * (C + 2B)\n        A ./= maximum(bOp₂ * A)\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"foo1 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark foo1(copy(data), bOp₁, bOp₂)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  6.07 GiB\n  allocs estimate:  2292\n  --------------\n  minimum time:     3.743 s (1.29% GC)\n  median time:      3.840 s (2.67% GC)\n  mean time:        3.840 s (2.67% GC)\n  maximum time:     3.937 s (3.99% GC)\n  --------------\n  samples:          2\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Using the methods we have seen earlier, we can quickly optimize this code, and we get something like that:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function foo2(A, bOp₁, bOp₂)\n    combOp = (bOp₁ - 2.5*I) * bOp₁\n    C = similar(A)\n    buffer1 = similar(A)\n    B = similar(A)\n    buffer2 = Array{Float64}(undef, (300, 300, 50, 10))\n    for i = 1:10\n        mul!(C, combOp, A)\n        @. buffer1 = C - 3A\n        mul!(B, bOp₁, buffer1)\n        @. buffer1 = C + 2B\n        mul!(A, bOp₁, buffer1)\n        A ./= maximum(mul!(buffer2, bOp₂, A))\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"foo2 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark foo2(copy(data), bOp₁, bOp₂)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  515.00 MiB\n  allocs estimate:  284\n  --------------\n  minimum time:     2.597 s (0.00% GC)\n  median time:      2.626 s (0.08% GC)\n  mean time:        2.626 s (0.08% GC)\n  maximum time:     2.656 s (0.16% GC)\n  --------------\n  samples:          2\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"This speedup is pretty much pleasing, but the tradeoff is that the code is much less readable now. To avoid the mess caused by manual optimization, the FunctionOperators library offers the @♻ macro that does the same automatically using the following markers: 🔝, 🔃, and @🔃.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"?@♻","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Recycling macro: Reduce the number of allocations inside a for loop by preallocation of arrays for the outputs of marked operations. Markers: @♻ (\\:recycle:), 🔝 (\\:top:), 🔃 (\\:arrows_clockwise:), and @🔃","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Macro @♻ should be placed right before a for loop, and then it executes the following substitutions:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Expressions marked by 🔝:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"They are going to be calculated before the loop, the result is stored in a variable, and the expression will be replaced by that variable. It also can be useful when a constant expression is used in the loop, but the idea behind creating that substitution is to allow caching of composite FunctionMatrices. Eg:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@♻ for i=1:5\n    result = 🔝((FuncOp₁ + 2I) * FuncOp₂) * data\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"will be transformed to ","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"🔝_1 = (FuncOp₁ + 2I) * FuncOp₂\nfor i = 1:5\n    result = 🔝_1 * data\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"so that way plan is calculated only once, and also buffers for intermediate results of the composite operator are allocated once.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Expressions marked by 🔃:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"They are going to be calculated before the loop (to allocate an array to store the result), but the expression is also evaluated in each loop iteration. The difference after the substitution is that the result of the expression is always saved to the preallocated array. Eg:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@♻ for i=1:5\n    result = FuncOp₁ * 🔃(A + B)\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"will be transformed to ","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"🔃_1 = A + B\nfor i = 1:5\n    result = FuncOp₁ * @.(🔃_1 = A + B)\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"This transformation first allocates an array named 🔃_1, and then in every iteration it is recalculated, saved to 🔃_1, and the this value is used for the rest of the operation (i.e.: FuncOp₁ * 🔃_1. Note that @. macro is inserted before the inline assignment. This is needed otherwise A + B would allocate a new array before it is stored in 🔃_1. Warning! It can break your code, e.g. @.(🔃_1 = A * B) ≠ (🔃_1 = A .* B) {matrix multiplication vs. elementwise multiplication}! On the other hand, when the marked expression consists only a multiplication, then it is transformed into a call of mul!. Eg:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@♻ for i=1:5\n    result = FuncOp₁ * 🔃(A * B)\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"will be transformed to ","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"🔃_1 = A * B\nfor i = 1:5\n    result = FuncOp₁ * mul!(🔃_1, A, B)\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Lastly, assignments marked by @🔃:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"They will be transformed into a call of mul!. Of course, it works only if @🔃 is directly followed by an assignment that has a single multiplication on the right side. Eg:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@♻ for i=1:5\n    @🔃 result = FuncOp₁ * A\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"will be transformed to ","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"result = FuncOp₁ * A\nfor i = 1:5\n    mul!(result, FuncOp₁, A)\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Final note: 🔝 can be arbitrarily nested, and it can be embedded in expressions marked by 🔃. 🔃 can also be nested, and it can be used in assigments marked by @🔃 (along with 🔝, of course).","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"In our example:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperators_global_settings.macro_verbose = true # if true, @♻ prints the transformed loop\nfunction foo3(A, bOp₁, bOp₂)\n    @♻ for i in 1:10\n        @🔃 C = 🔝((bOp₁ - 2.5*I) * bOp₁) * A\n        @🔃 B = bOp₁ * 🔃(C - 3A)\n        @🔃 A .= bOp₁ * 🔃(C + 2B)\n        A ./= maximum(🔃(bOp₂ * A))\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"begin\n    🔝_1 = (bOp₁ - 2.5I) * bOp₁\n    C = 🔝_1 * A\n    🔃_2 = C - 3A\n    🔃_3 = 3A\n    B = bOp₁ * (🔃_3 .= C .- mul!(🔃_3, 3, A))\n    🔃_5 = C + 2B\n    🔃_6 = 2B\n    🔃_7 = bOp₂ * A\n    for i = 1:10\n        mul!(C, 🔝_1, A)\n        mul!(B, bOp₁, 🔃_3 .= C .- mul!(🔃_3, 3, A))\n        mul!(A, bOp₁, 🔃_6 .= C .+ mul!(🔃_6, 2, B))\n        A ./= maximum(mul!(🔃_7, bOp₂, A))\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"foo3 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark foo3(copy(data), bOp₁, bOp₂)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  686.66 MiB\n  allocs estimate:  419\n  --------------\n  minimum time:     2.962 s (0.00% GC)\n  median time:      3.017 s (0.12% GC)\n  mean time:        3.017 s (0.12% GC)\n  maximum time:     3.072 s (0.24% GC)\n  --------------\n  samples:          2\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"It is slightly slower and requires a bit more memory allocations because it can't detect if a buffer can be reused. But when the loop body consists of a lot of computationally heavy operations, then the difference is mostly negligible.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"However, use of @♻ is still tedious for more complex algorithms. Fortunately, the same (or even better) optimization can be achieved by using the @recycle macro!","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"?@recycle","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Speed up iteratively executed code fragments with many matrix operations by transforming code in such a way that preserves arrays allocated for intermediate results, and re-use them for subsequent iterations.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"First variant:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@recycle <code to be optimized>","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Second variant:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@recycle(arrays = [<list of array variables>], funops = [<list of funop variables], numbers = [<list of number variables>], <code to be optimized>)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"The first variant is the more convenient one that tries to guess the type of variables (the other variant requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. As a tradeoff, this variant fails when the optimized code contains either a closure or non-const global variable.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"The second variant is the more flexible (and also more verbose) one one that requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. The other variant tries to guess the type of variables, thus it is more convenient, but as a tradeoff, that variant fails when the optimized code contains either a closure or non-const global variable. On the other hand, this (more verbose) variant is free from these limitations. Note: All of the \"keyword arguments\" are optional, and also their order is arbitrary.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"An example to first variant: This function","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function foo()\n    A = rand(100,100)\n    B = rand(100,100)\n    @recycle for i = 1:5\n        A += A / 2 + B\n        C = A * B + 5\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"is turned into the following:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function foo()\n    A = rand(100,100)\n    B = rand(100,100)\n    (C, 🔃₂) = fill(nothing, 2)\n    (is_first_run₁,) = fill(true, 1)\n    for i = 1:5\n        A .+= A ./ 2 .+ B\n        if is_first_run₁\n            is_first_run₁ = false\n            🔃₂ = A * B\n            C = 🔃₂ .+ 5\n        else\n            mul!(🔃₂, A, B)\n            C .= 🔃₂ .+ 5\n        end\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Another example showing what second variant can do (and the first can't):","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"bar = @recycle(arrays=[A,B], (A, B) -> begin\n    A += A / 2 + B\n    B = A * B .+ 5\nend)\nfunction baz()\n    A = rand(100,100)\n    B = rand(100,100)\n    for i = 1:5\n        bar(A,B)\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"is turned into the following:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"bar = begin\n    (🔃₁,) = fill(nothing, 1)\n    (is_first_run₁,) = fill(true, 1)\n    (A, B)->begin\n            A .+= A ./ 2 .+ B\n            begin\n                if is_first_run₁\n                    is_first_run₁ = false\n                    🔃₁ = A * B\n                else\n                    mul!(🔃₁, A, B)\n                end\n                B .= 🔃₁ .+ 5\n            end\n        end\nend\nfunction baz()\n    A = rand(100,100)\n    B = rand(100,100)\n    for i = 1:5\n        bar(A,B)\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function foo4(A, bOp₁, bOp₂)\n    @recycle for i in 1:10\n        C = (bOp₁ - 2.5*I) * bOp₁ * A\n        B = bOp₁ * (C - 3A)\n        A .= bOp₁ * (C + 2B)\n        A ./= maximum(bOp₂ * A)\n    end\nend","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"foo4 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark foo4(copy(data), bOp₁, bOp₂)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"1 | begin\n  2 |     🔝₁ = bOp₁ - 2.5I\n  3 |     🔝₂ = 🔝₁ * bOp₁\n  4 |     (🔃₁, 🔃₁, 🔃₃, 🔃₃, 🔃₅) = fill(nothing, 5)\n  5 |     (is_first_run₁, is_first_run₂, is_first_run₃, is_first_run₄) = fill(true, 4)\n  6 |     for i = 1:10\n  7 |         if is_first_run₁\n  8 |             is_first_run₁ = false\n  9 |             C = 🔝₂ * A\n 10 |         else\n 11 |             mul!(C, 🔝₂, A)\n 12 |         end\n 13 |         if is_first_run₂\n 14 |             is_first_run₂ = false\n 15 |             🔃₁ = C .- 3 .* A\n 16 |             B = bOp₁ * 🔃₁\n 17 |         else\n 18 |             🔃₁ .= C .- 3 .* A\n 19 |             mul!(B, bOp₁, 🔃₁)\n 20 |         end\n 21 |         if is_first_run₃\n 22 |             is_first_run₃ = false\n 23 |             🔃₃ = C .+ 2 .* B\n 24 |         else\n 25 |             🔃₃ .= C .+ 2 .* B\n 26 |         end\n 27 |         mul!(A, bOp₁, 🔃₃)\n 28 |         if is_first_run₄\n 29 |             is_first_run₄ = false\n 30 |             🔃₅ = bOp₂ * A\n 31 |         else\n 32 |             mul!(🔃₅, bOp₂, A)\n 33 |         end\n 34 |         A ./= maximum(🔃₅)\n 35 |     end\n 36 | end","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  549.33 MiB\n  allocs estimate:  367\n  --------------\n  minimum time:     2.350 s (0.00% GC)\n  median time:      2.560 s (0.00% GC)\n  mean time:        2.521 s (0.10% GC)\n  maximum time:     2.652 s (0.00% GC)\n  --------------\n  samples:          3\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Notice that it is even better than foo3 (which is optimized with @♻)!","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Another comment: the first (more conveniable) variant of @recycle uses a generated function to infer the types of variables. That's why it is unable to optimize closures, and codes containing non-const global variables, and also, this is the reason why it prints the optimized code when the optimized function executed first. Of course, if you set FunctionOperators_global_settings to false, then it is not printed at first execution.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Third comment: both variant of @recycle macro increases significantly the compilation time.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Furthermore, it is also possible to optimize small functions/closures with @recycle, if they called multiple times, and the size of their input arrays are always the same. However, we also need to declare explicitly which variables are Arrays, FunOps, or Numbers in this case.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function getCost(Op)\n    (A,scaler) -> norm(Op' * (A / scaler), 1) + norm(A, 2)\nend\ncost = getCost(bOp₁)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"#50 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark cost(data, 2)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  68.67 MiB\n  allocs estimate:  103\n  --------------\n  minimum time:     56.325 ms (0.00% GC)\n  median time:      57.134 ms (0.00% GC)\n  mean time:        58.370 ms (1.57% GC)\n  maximum time:     80.134 ms (27.98% GC)\n  --------------\n  samples:          86\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"function getCost_recycle(Op)\n    @recycle(arrays=[A], funops=[Op], numbers=[scaler],\n        (A,scaler) -> norm(Op' * (A / scaler), 1) + norm(A, 2))\nend\ncost2 = getCost_recycle(bOp₁)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"1 | begin\n  2 |     🔝₁ = Op'\n  3 |     (🔃₁, 🔃₂, 🔃₂) = fill(nothing, 3)\n  4 |     (is_first_run₁,) = fill(true, 1)\n  5 |     (A, scaler)->begin\n  6 |             if is_first_run₁\n  7 |                 is_first_run₁ = false\n  8 |                 🔃₂ = A ./ scaler\n  9 |                 🔃₁ = 🔝₁ * 🔃₂\n 10 |             else\n 11 |                 🔃₂ .= A ./ scaler\n 12 |                 mul!(🔃₁, 🔝₁, 🔃₂)\n 13 |             end\n 14 |             norm(🔃₁, 1) + norm(A, 2)\n 15 |         end\n 16 | end","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"#53 (generic function with 1 method)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"@benchmark cost2(data, 2)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"BenchmarkTools.Trial: \n  memory estimate:  96 bytes\n  allocs estimate:  5\n  --------------\n  minimum time:     41.945 ms (0.00% GC)\n  median time:      42.068 ms (0.00% GC)\n  mean time:        42.076 ms (0.00% GC)\n  maximum time:     43.024 ms (0.00% GC)\n  --------------\n  samples:          119\n  evals/sample:     1","category":"page"},{"location":"Tutorial/#Further-notes-1","page":"Tutorial","title":"Further notes","text":"","category":"section"},{"location":"Tutorial/#Global-settings-1","page":"Tutorial","title":"Global settings","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"?FunctionOperators_global_settings","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"search: \u001b[0m\u001b[1mF\u001b[22m\u001b[0m\u001b[1mu\u001b[22m\u001b[0m\u001b[1mn\u001b[22m\u001b[0m\u001b[1mc\u001b[22m\u001b[0m\u001b[1mt\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mo\u001b[22m\u001b[0m\u001b[1mn\u001b[22m\u001b[0m\u001b[1mO\u001b[22m\u001b[0m\u001b[1mp\u001b[22m\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mr\u001b[22m\u001b[0m\u001b[1ma\u001b[22m\u001b[0m\u001b[1mt\u001b[22m\u001b[0m\u001b[1mo\u001b[22m\u001b[0m\u001b[1mr\u001b[22m\u001b[0m\u001b[1ms\u001b[22m\u001b[0m\u001b[1m_\u001b[22m\u001b[0m\u001b[1mg\u001b[22m\u001b[0m\u001b[1ml\u001b[22m\u001b[0m\u001b[1mo\u001b[22m\u001b[0m\u001b[1mb\u001b[22m\u001b[0m\u001b[1ma\u001b[22m\u001b[0m\u001b[1ml\u001b[22m\u001b[0m\u001b[1m_\u001b[22m\u001b[0m\u001b[1ms\u001b[22m\u001b[0m\u001b[1me\u001b[22m\u001b[0m\u001b[1mt\u001b[22m\u001b[0m\u001b[1mt\u001b[22m\u001b[0m\u001b[1mi\u001b[22m\u001b[0m\u001b[1mn\u001b[22m\u001b[0m\u001b[1mg\u001b[22m\u001b[0m\u001b[1ms\u001b[22m","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Object that holds global settings for FunctionOperators library","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Fields:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"verbose::Bool If set to true, then allocation information and calculated plan function will be displayed upon creation (i.e., when a composite operator is first used). Default: false\nmacro_verbose::Bool If set to true, then recycling macros (@♻ and @recycle) will print the transformed code. Default: false\nauto_reshape::Bool If set to true, then input and output is reshaped according to the inDims and outDims values of the FunctionOperator before and after any multiplication. Default: false","category":"page"},{"location":"Tutorial/#Example-for-auto_reshape-1","page":"Tutorial","title":"Example for auto_reshape","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"op = FunctionOperator{Float64}(forw = x -> x[:], inDims = (3,2), outDims = (2,3))\nsize(op * ones(3,2))","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(6,)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"FunctionOperators_global_settings.auto_reshape = true\nsize(op * ones(6, 1)) # reshaped both before and after!","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(2, 3)","category":"page"},{"location":"Tutorial/#Equality-operator-1","page":"Tutorial","title":"Equality operator","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Equality check based on name","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"HEADS UP! This works only when operators with the same name has also the same functionality!","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"It performs basic arithmetic transformations on the expressions, so it recognizes even some less obvious equalities. The rules it uses:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Associativity: op1 * op2 * op3 = (op1 * op2) * op3 = op1 * (op2 * op3), op1 + op2 + op3 = (op1 + op2) + op3 = op1 + (op2 + op3), op1 + (op2 - op3) == (op1 + op2) - op3, op1 - (op2 + op3) == (op1 - op2) - op3\nCommutativity: op1 - op2 - op3 = op1 - op3 - op2, op1 + op2 = op2 + op1\nDistributivity: (op1 + op2) * op3 = op1 * op3 + op2 * op3 (Note that op1 * (op2 + op3)  op1 * op2 + op1 * op3)","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"In our case, this implies:","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"# Note that Op₁ and bOp₁ are defined with the same name field!\n(bOp₁ + 2.5*I) * bOp₁ == (Op₁ + 2.5*I) * Op₁ == 2.5*I * Op₁ + bOp₁ * Op₁","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"true","category":"page"},{"location":"Tutorial/#Superclass-1","page":"Tutorial","title":"Superclass","text":"","category":"section"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"Combination of FunctionOperator objects are type of FunctionOperatorComposite. Both class is subclass of FunOp.","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"bOp₁ isa FunctionOperator,\nbOp₁ isa FunOp,\nbOp₂ * bOp₁ isa FunctionOperator, # false bacause it is FunctionOperatorComposite\nbOp₂ * bOp₁ isa FunOp","category":"page"},{"location":"Tutorial/#","page":"Tutorial","title":"Tutorial","text":"(true, true, false, true)","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [FunctionOperators]\nOrder   = [:function, :type, :macro, :constant]","category":"page"},{"location":"reference/#FunctionOperators.setPlan","page":"Reference","title":"FunctionOperators.setPlan","text":"Manually set the plan of a FunctionOperator Arguments:\n\nFO composite FunctionOperator to be changed\nf manually defined plan (function with two arguments, first is the output buffer, second is the input array)\nf_str (Optional) string representation of the plan\n\n\n\n\n\n","category":"function"},{"location":"reference/#FunctionOperators.FunOp","page":"Reference","title":"FunctionOperators.FunOp","text":"Supertype for FunctionOperator and FunctionOperatorComposite\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionOperators.FunctionOperator","page":"Reference","title":"FunctionOperators.FunctionOperator","text":"FunctionOperator is an operator that maps from a multidimensional space to another multidimensional space. The mapping is defined by a function (forw), and optionally the reverse mapping can also be defined (backw). The input the mapping must be subtype of AbstractArray.\n\nThe following constructors are available:\n\nPositional constructor #1: FunctionOperator{eltype}(forw, inDims, outDims)\nPositional constructor #2: FunctionOperator{eltype}(forw, backw, inDims, outDims)\nPositional constructor #3: FunctionOperator{eltype}(name, forw, inDims, outDims)\nPositional constructor #4: FunctionOperator{eltype}(name, forw, backw, inDims, outDims)\nKeyword constructor: FunctionOperator{eltype}(;kwargs...)\n\nwhere eltype is the type enforced on elements of input array.\n\nArguments\n\nname::String (Optional but strongly recommended) The operator is referenced later in error messages by this string. Warning! It is also used to check equality of (composite) FunctionOperators. Default value: OpX where X is a number incremented in each constructor-call.\nforw::Function Function defining the mapping. Must accept one or two arguments. In case of two arguments, the first argument is a preallocated buffer to write the result into (to speed up code by avoiding repeated allocations). In case of both one and two arguments, the return value must be the result of the mapping.\nbackw::Function (Optional) Same as backw, but defines the backward mapping\ninDims::Tuple{Vararg{Int}} Size of input array\noutDims::Tuple{Vararg{Int}} Size of output array\n\n\n\n\n\n","category":"type"},{"location":"reference/#FunctionOperators.@recycle-Tuple{Any}","page":"Reference","title":"FunctionOperators.@recycle","text":"Speed up iteratively executed code fragments with many matrix operations by transforming code in such a way that preserves arrays allocated for intermediate results, and re-use them for subsequent iterations.\n\nFirst variant:\n\n@recycle <code to be optimized>\n\nSecond variant:\n\n@recycle(arrays = [<list of array variables>], funops = [<list of funop variables], numbers = [<list of number variables>], <code to be optimized>)\n\nThe first variant is the more convenient one that tries to guess the type of variables (the other variant requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. As a tradeoff, this variant fails when the optimized code contains either a closure or non-const global variable.\n\nThe second variant is the more flexible (and also more verbose) one one that requires its user to declare explicitly the list of variables which are type of Array, FunOp, and Number. The other variant tries to guess the type of variables, thus it is more convenient, but as a tradeoff, that variant fails when the optimized code contains either a closure or non-const global variable. On the other hand, this (more verbose) variant is free from these limitations. Note: All of the \"keyword arguments\" are optional, and also their order is arbitrary.\n\nAn example to first variant: This function\n\nfunction foo()\n    A = rand(100,100)\n    B = rand(100,100)\n    @recycle for i = 1:5\n        A += A / 2 + B\n        C = A * B + 5\n    end\nend\n\nis turned into the following:\n\nfunction foo()\n    A = rand(100,100)\n    B = rand(100,100)\n    (C, 🔃₂) = fill(nothing, 2)\n    (is_first_run₁,) = fill(true, 1)\n    for i = 1:5\n        A .+= A ./ 2 .+ B\n        if is_first_run₁\n            is_first_run₁ = false\n            🔃₂ = A * B\n            C = 🔃₂ .+ 5\n        else\n            mul!(🔃₂, A, B)\n            C .= 🔃₂ .+ 5\n        end\n    end\nend\n\nAnother example showing what second variant can do (and the first can't):\n\nbar = @recycle(arrays=[A,B], (A, B) -> begin\n    A += A / 2 + B\n    B = A * B .+ 5\nend)\nfunction baz()\n    A = rand(100,100)\n    B = rand(100,100)\n    for i = 1:5\n        bar(A,B)\n    end\nend\n\nis turned into the following:\n\nbar = begin\n    (🔃₁,) = fill(nothing, 1)\n    (is_first_run₁,) = fill(true, 1)\n    (A, B)->begin\n            A .+= A ./ 2 .+ B\n            begin\n                if is_first_run₁\n                    is_first_run₁ = false\n                    🔃₁ = A * B\n                else\n                    mul!(🔃₁, A, B)\n                end\n                B .= 🔃₁ .+ 5\n            end\n        end\nend\nfunction baz()\n    A = rand(100,100)\n    B = rand(100,100)\n    for i = 1:5\n        bar(A,B)\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"reference/#FunctionOperators.@♻-Tuple{Any}","page":"Reference","title":"FunctionOperators.@♻","text":"Recycling macro: Reduce the number of allocations inside a for loop by preallocation of arrays for the outputs of marked operations. Markers: @♻ (\\:recycle:), 🔝 (\\:top:), 🔃 (\\:arrows_clockwise:), and @🔃\n\nMacro @♻ should be placed right before a for loop, and then it executes the following substitutions:\n\nExpressions marked by 🔝:\n\nThey are going to be calculated before the loop, the result is stored in a variable, and the expression will be replaced by that variable. It also can be useful when a constant expression is used in the loop, but the idea behind creating that substitution is to allow caching of composite FunctionMatrices. Eg:\n\n@♻ for i=1:5\n    result = 🔝((FuncOp₁ + 2I) * FuncOp₂) * data\nend\n\nwill be transformed to \n\n🔝_1 = (FuncOp₁ + 2I) * FuncOp₂\nfor i = 1:5\n    result = 🔝_1 * data\nend\n\nso that way plan is calculated only once, and also buffers for intermediate results of the composite operator are allocated once.\n\nExpressions marked by 🔃:\n\nThey are going to be calculated before the loop (to allocate an array to store the result), but the expression is also evaluated in each loop iteration. The difference after the substitution is that the result of the expression is always saved to the preallocated array. Eg:\n\n@♻ for i=1:5\n    result = FuncOp₁ * 🔃(A + B)\nend\n\nwill be transformed to \n\n🔃_1 = A + B\nfor i = 1:5\n    result = FuncOp₁ * @.(🔃_1 = A + B)\nend\n\nThis transformation first allocates an array named 🔃_1, and then in every iteration it is recalculated, saved to 🔃_1, and the this value is used for the rest of the operation (i.e.: FuncOp₁ * 🔃_1. Note that @. macro is inserted before the inline assignment. This is needed otherwise A + B would allocate a new array before it is stored in 🔃_1. Warning! It can break your code, e.g. @.(🔃_1 = A * B) ≠ (🔃_1 = A .* B) {matrix multiplication vs. elementwise multiplication}! On the other hand, when the marked expression consists only a multiplication, then it is transformed into a call of mul!. Eg:\n\n@♻ for i=1:5\n    result = FuncOp₁ * 🔃(A * B)\nend\n\nwill be transformed to \n\n🔃_1 = A * B\nfor i = 1:5\n    result = FuncOp₁ * mul!(🔃_1, A, B)\nend\n\nLastly, assignments marked by @🔃:\n\nThey will be transformed into a call of mul!. Of course, it works only if @🔃 is directly followed by an assignment that has a single multiplication on the right side. Eg:\n\n@♻ for i=1:5\n    @🔃 result = FuncOp₁ * A\nend\n\nwill be transformed to \n\nresult = FuncOp₁ * A\nfor i = 1:5\n    mul!(result, FuncOp₁, A)\nend\n\nFinal note: 🔝 can be arbitrarily nested, and it can be embedded in expressions marked by 🔃. 🔃 can also be nested, and it can be used in assigments marked by @🔃 (along with 🔝, of course).\n\n\n\n\n\n","category":"macro"},{"location":"reference/#FunctionOperators.FunctionOperators_global_settings","page":"Reference","title":"FunctionOperators.FunctionOperators_global_settings","text":"Object that holds global settings for FunctionOperators library\n\nFields:\n\nverbose::Bool If set to true, then allocation information and calculated plan function will be displayed upon creation (i.e., when a composite operator is first used). Default: false\nmacro_verbose::Bool If set to true, then recycling macros (@♻ and @recycle) will print the transformed code. Default: false\nauto_reshape::Bool If set to true, then input and output is reshaped according to the inDims and outDims values of the FunctionOperator before and after any multiplication. Default: false\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Base.:==-Tuple{FunctionOperators.FunctionOperatorComposite,FunctionOperators.FunctionOperatorComposite}","page":"Reference","title":"Base.:==","text":"Equality check based on name\n\nHEADS UP! This works only when operators with the same name has also the same functionality!\n\nIt performs basic arithmetic transformations on the expressions, so it recognizes even some less obvious equalities. The rules it uses:\n\nAssociativity: op1 * op2 * op3 = (op1 * op2) * op3 = op1 * (op2 * op3), op1 + op2 + op3 = (op1 + op2) + op3 = op1 + (op2 + op3), op1 + (op2 - op3) == (op1 + op2) - op3, op1 - (op2 + op3) == (op1 - op2) - op3\nCommutativity: op1 - op2 - op3 = op1 - op3 - op2, op1 + op2 = op2 + op1\nDistributivity: (op1 + op2) * op3 = op1 * op3 + op2 * op3 (Note that op1 * (op2 + op3)  op1 * op2 + op1 * op3)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.eltype-Union{Tuple{Type{FunctionOperator{T}}}, Tuple{T}} where T","page":"Reference","title":"Base.eltype","text":"Determine type of elements of array accepted by this operator\n\n\n\n\n\n","category":"method"},{"location":"#FunctionOperators.jl-1","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"","category":"section"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"(Image: ) (Image: Build Status) (Image: codecov)","category":"page"},{"location":"#Motivation-1","page":"FunctionOperators.jl","title":"Motivation","text":"","category":"section"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"I wanted to write code for image reconstruction in Julia, which","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"resambles the mathematical notation with abstract operators on multidimensional spaces,\nhas minimal memory requirement and fast to run, and\nis easy to write and read.","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"FunctionOperator is an operator that maps from a multidimensional space to another multidimensional space. The mapping is defined by a function (forw), and optionally the reverse mapping can also be defined (backw). The input the mapping must be subtype of AbstractArray.","category":"page"},{"location":"#Examples-1","page":"FunctionOperators.jl","title":"Examples","text":"","category":"section"},{"location":"#Create-operator-1","page":"FunctionOperators.jl","title":"Create operator","text":"","category":"section"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"The 2D Fourier transformation operator:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> using FFTW\njulia> 𝓕 = FunctionOperator{Complex{Float64}}(\n            forw = x -> fft(x, (1,2)), backw = x -> ifft(x, (1,2)),\n            inDims = (128, 128), outDims = (128, 128))","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"Finite differences / Total Variance operator:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> ∇ = FunctionOperator{Complex{Float64}}(\n            forw = x -> (circ(x, (1,0)) - x).^2 + (circ(x, (0,1)) - x).^2,\n            inDims = (128, 128), outDims = (128, 128))","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"Or a sampling operator:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> mask = rand(128, 128) .< 0.3\njulia> S = FunctionOperator{Complex{Float64}}(\n            forw = x -> x[mask], backw = x -> embed(x, mask),\n            inDims = (128, 128), outDims = (sum(mask),))","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"Then these operators can be combined (almost) arbitrarily:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> x = rand(128, 128);\njulia> 𝓕 * ∇ * x == fft((circ(x, (1,0)) - x).^2 + (circ(x, (0,1)) - x).^2, (1,2))\ntrue\njulia> combined = S * (𝓕 + ∇);\njulia> combined * x == S * 𝓕 * x + S * ∇ * x\ntrue","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"They can be combined with UniformScaling from LinearAlgebra:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> using LinearAlgebra\njulia> 3I * ∇ * x == 3 * (∇ * x)\ntrue\njulia> (𝓕 + (3+2im)I) * x == 𝓕 * x + (3+2im) * x\ntrue","category":"page"},{"location":"#Performance-1","page":"FunctionOperators.jl","title":"Performance","text":"","category":"section"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"With little effort we can achieve the same speed as we would have manually optimized functions. For example, consider the following function:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> using BenchmarkTools\njulia> FFT_plan = plan_fft(x, (1,2));\njulia> iFFT_plan = plan_ifft!(x, (1,2));\njulia> function foo(output::Array{Complex{Float64},2}, x::Array{Complex{Float64},2},\n                FFT_plan, iFFT_plan, mask::BitArray)\n            mul!(output, FFT_plan, x)\n            output .*= mask\n            mul!(output, iFFT_plan, output)\n        end;\njulia> output = similar(x);\njulia> @benchmark foo(output, x, FFT_plan, iFFT_plan, mask)\nBenchmarkTools.Trial:\n  memory estimate:  0 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     390.961 μs (0.00% GC)\n  median time:      418.149 μs (0.00% GC)\n  mean time:        408.111 μs (0.00% GC)\n  maximum time:     497.468 μs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"That function basically consist of three operations: A Fourier transform, a masking, and an inverse Fourier transform. Using FunctionOperators, we can write code that is more similar to the high-level description that has minimal run-time and memory overhead:","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"julia> 𝓕₂ = FunctionOperator{Complex{Float64}}(\n            forw = (output, x) -> mul!(output, FFT_plan, x),\n            backw = (output, x) -> mul!(output, iFFT_plan, x),\n            inDims = (128, 128), outDims = (128, 128));\njulia> S₂ = FunctionOperator{Complex{Float64}}(\n            forw = (output, x) -> output .= x .* mask,\n            inDims = (128, 128), outDims = (128, 128));\njulia> combined = 𝓕₂' * S₂ * 𝓕₂;\njulia> @benchmark mul!(output, combined, x)\nBenchmarkTools.Trial:\n  memory estimate:  112 bytes\n  allocs estimate:  4\n  --------------\n  minimum time:     401.814 μs (0.00% GC)\n  median time:      429.648 μs (0.00% GC)\n  mean time:        427.211 μs (0.00% GC)\n  maximum time:     681.116 μs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"For more detailed description, see tutorial.","category":"page"},{"location":"#Related-packages-1","page":"FunctionOperators.jl","title":"Related packages","text":"","category":"section"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"Not a Julia package, but the main motivation behind creating this package is to have the same functionality as fatrix2 in the Matlab version of Michigan Image Reconstruction Toolbox (MIRT), (description).","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"The most similar Julia package is AbstractOperators.jl. The feature set of its MyLinOp type largely overlaps with FunctionOperator's features. The main difference is that composition in AbstractOperators is more intensive memory-wise as it allocates a buffer for each member of composition while FunctionOperators allocates a new buffer only when necessary. On the other hand, the difference between is significant only for memory-intensive applications.","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"FunctionOperators was also inspired by LinearMaps.jl  The main difference is that LinearMaps support only mappings where the input and output are both vectors (which is often not the case in image reconstruction algorithms). LinearMapsAA.jl is an extension of LinearMaps.jl with getindex and setindex! functions making it conform to the requirements of an AbstractMatrix type. Additionally, a user can include a NamedTuple of properties with it, and then retrieve those later using the A.key syntax like one would do with a struct (composite type). From implementational point of view, both LinearMaps.jl and LinearMapsAA.jl uses more memory when LinearMaps with different input and output size are composed.","category":"page"},{"location":"#","page":"FunctionOperators.jl","title":"FunctionOperators.jl","text":"LinearOperators provides some similar features too, but it also requires the input and the output to be a vector.","category":"page"}]
}
